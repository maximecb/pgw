<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Positive Results for Higgs</title>
  <link rel="stylesheet" href="../../../../style.css">
  <link rel="alternate" type="application/rss+xml" title="Pointers Gone Wild RSS Feed" href="/rss.xml">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">

  <!-- Social media card -->
  <meta property="og:type" content="article">
  <meta property="og:title" content="Positive Results for Higgs">
  <meta property="og:description" content="Positive Results for Higgs">
  <meta property="og:image" content="https://pointersgonewild.com/2014/04/10/positive-results-for-higgs/7vt91.jpg">
  <meta name="twitter:card" content="summary_large_image">
</head>

<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-DC24K385F8"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-DC24K385F8');
</script>

<script>
document.addEventListener('keydown', (e) => {
    let ctrlDown = e.ctrlKey || e.metaKey;

    // Ctrl + C
    if (ctrlDown && e.key.toUpperCase() === 'C') {
        if (window.getSelection().toString().length == 0) {
            navigator.clipboard.writeText("open site/2014-04-10-positive-results-for-higgs/index.md");
        }
    }

    // Shift + left arrow
    if (e.shiftKey && event.keyCode === 37) {
        window.location.href = "../../../../2014/03/19/how-i-hacked-my-stationary-bike-and-voided-its-warranty/";
    }

    // Shift + right arrow
    if (e.shiftKey && event.keyCode === 39) {
        window.location.href = "../../../../2014/05/08/news-of-higgs/";
    }
});
</script>

<body>
<div class="container">

<div class="top_bar">
  <div class="pgw">
    <a href="../../../..">Pointers Gone Wild</a>
  </div>
  <nav>
    <a href="../../../../about/">About</a>
    <a href="https://github.com/maximecb">GitHub</a>
    <a href="https://x.com/love2code">x.com</a>

    <!--
    <a href="../../../../about/">About</a>
    <a href="../../../../about/">Projects</a>
    <a href="https://github.com/maximecb"><img style="width: 1.2rem;" src="/github_icon.svg" alt="GitHub account"/></a>
    <a href="https://x.com/love2code"><img style="width: 1.2rem;" src="/x_icon.svg" alt="x.com account"/></a>
    <a href="/feed.xml"><img style="width: 1.2rem;" src="/rss_icon.svg" alt="RSS feed"/></a>
    -->
  </nav>
</div>

<div class="contents">
<div class="page_title">
<h1>Positive Results for Higgs</h1>
<div class="post_date">April 10th, 2014</div>
</div>
<div class="cover_image">
<img src="7vt91.jpg">
</div>
<p>Great news! The Higgs <a href="https://github.com/maximecb/Higgs">GitHub repository</a> has 204 stars and 22 forks at the time of this writing. Even better news, however, is that I've finally reached a point where <a href="/2013/10/31/higgs-the-first-jit-compiler-of-its-kind/">Basic Block Versioning</a> (BBV), the compiler optimization technique I've been implementing in Higgs as part of my PhD thesis, finally delivers measurable speedups on benchmark programs. Although I was able to <a href="http://arxiv.org/abs/1401.3041">demonstrate</a> a few months back that BBV is able to eliminate dynamic type checks quite effectively, one important problem remained, which is that this didn't immediately translate in improvements in terms of running time. Many optimizations are required in order to make dynamic languages fast, and the quality of the code generated by Higgs was just too poor: removing 50% of type tests or more didn't make a noticeable performance impact. It was like removing one drop from a bucket of inefficiency.</p>
<p>Recently, after measuring that property access took more than 30% of the execution time in some benchmarks, I decided to implement <a href="http://en.wikipedia.org/wiki/Inline_caching">inline caching</a> into Higgs. This provided noticeable speedups, but still didn't make BBV win out in terms of running time. In fact, the results on most benchmarks were worse with versioning enabled. I concluded that the issue was probably largely one of code size. By generating multiple versions for some code paths, the code size increases. This can result in worse performance in terms of instruction cache accesses. Modern CPUs have large L2 and L3 caches multiple megabytes in size, but the <a href="http://en.wikipedia.org/wiki/CPU_cache">instruction cache</a> of the Core i7 is still just a puny 32 kilobytes. This cache is easily filled up, especially if the code you're generating is rather bloated.  Hence, I decided that my next focus should be to try and optimize the size of the machine code generated by Higgs.</p>
<p>I started by implementing a very naive on-the-fly <a href="http://en.wikipedia.org/wiki/Register_allocation">register allocator</a>. The first version spilled values very conservatively and produced many redundant writes and spills whose only purpose was to avoid having the <a href="http://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">Garbage Collector</a> (GC) ever seeing false pointers (a flaw which has now been fixed). My main concern was to get Higgs to pass all its tests with the register allocator, and only then to optimize it. After many hours of debugging, I got it all working, and to my surprise, despite all the redundant operations, the unoptimized register allocator produced much smaller code and much improved performance. The performance was improved enough, in fact, that BBV finally won out in terms of running time on most benchmarks. I was extremely surprised to find out that on loop microbenchmarks, the naive register allocator produced code that ran more than 10 times faster than similar code loading and storing values on the stack. My conclusion is that when it comes to memory accesses, it's really the reads that kill performance as the CPU doesn't have to stall execution for redundant writes.</p>
<p>At this point, I've completed a few optimizations to the register allocator. Most of the redundant moves have been eliminated, but spilling still remain to be made less conservative. I've also stumbled upon a rather interesting finding. In some cases, it actually turns out that versioning doesn't increase code size, but actually decreases it. Sometimes, the code it produces is more optimized and more compact than the original. So far, the results are extremely encouraging, but I still believe I can improve on them with additional tweaks. These results are coming in just in time for my presentation in May at <a href="http://dconf.org/2014/">DConf 2014</a>. I'll also be submitting a new publication at a conference in early June.</p>
<p>The performance of the machine code generated by Higgs is slowly but surely becoming more competitive. As I see it, the main flaw Higgs has in terms of usability at this point is that the compilation time is rather slow. Compilation time now largely dominates execution time on most benchmarks. This is something I haven't had much time to look into. The codebase has become complex enough that I can't exactly pinpoint where the major inefficiencies might be without some digging. If you're interested in contributing to this project, profiling and optimizing parsing, analysis and code generation is something we could definitely use help on.</p>
<p>In other news, Molly Everett has delivered an updated version of the FFI library, and is now working on a graphics library of 2D graphics bindings for Higgs, which he used to create a Pong clone in JavaScript. Stay tuned!</p>
<div class="copyright">
    Copyright &copy; 2011&ndash;2025 Maxime Chevalier-Boisvert. All rights reserved.
</div>

</div> <!-- contents -->
</div> <!-- container -->

</body>
</html>
